---
title: redis缓存使用问题及解决办法
date: 2021-09-30
tags: 
- Java
categories:
- "后端"
---
## 哪些数据适合放到缓存
- 即时性，数据一致性要求不高的
- 访问量大且更新频率不高的(读多，写少)
![缓存流程](https://cdn.jsdelivr.net/gh/ShuiLinzi/blog-image@master/后端/缓存流程.2mcj5cis3se0.png)
## 本地缓存
项目是单体应用，很方便，很快，但是如果是分布式集群环境下，一旦对数据进行修改，比如对一号机器修改，但是由于负载均衡到二号三号机器的数据无法修改，也就是说本地缓存会产生数据一致性的问题。解决办法，使用服务器击群使用一个公共的共同的缓存中间件，redis能实现此功能
![分布式缓存](https://cdn.jsdelivr.net/gh/ShuiLinzi/blog-image@master/后端/分布式缓存.3wivdp10sts.png)

## redis缓存
- 给缓存中放json字符串，json跨语言，跨平台兼容，拿出来的时候也是字符串，这样可以保持格式的统一

## 内存问题
### 堆外溢出异常
- springboot2.0以后默认使用lettcue作为操作redis的客户端。它使用netty进行网络通信
- lettuce的bug导致netty堆外内存溢出
### 解决方案
调大堆外内存并不能从根本上解决问题，迟早会出现这个问题<br/>
redisTemplate:lettcue,jedis都是操控redis的底层客户端。spring再次封装成了redisTemplate
- 升级lettuce客户端
- 切换使用jedis客户端(我使用了此种方法，因为视频里面用的是这个，2333)

## 高并发缓存失效问题
### 缓存穿透
缓存穿透指查询一个不存在的数据，由于缓存不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的null写入缓存，这将导致这个不存在的数据每次都要请求到存储层去查询，失去了缓存的意义<br><br>
风险:利用不存在的数据进行攻击，数据库瞬间压力增大，最终导致崩溃<br><br>
解决:将null结果缓存，并加入短暂的过期时间

### 缓存雪崩
缓存雪崩是指我们设置缓存时key采用了相同的过期时间，导致缓存在某一个时刻同时失效，请求全部转发到数据库，数据库瞬时压力过重雪崩<br><br>
解决:原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的
重复率就会降低，就很难引发集体失效的事件
### 缓存击穿
对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常热点的数据这个时候，需要考虑一个问题：如果这个 key 在大量请求同时进来前正好失效，那么所
有对这个 key 的数据查询都落到 db，我们称为缓存击穿。<br><br>
解决:加锁<br><br>
(个人感觉：上述问题不用缓存也会存在吧，比如没有缓存高并发直接访问数据库，不也会炸吗)
## 加锁
### 单机模式加锁
单机模式加锁，使用synchronized(this)进行加锁
### 集群模式加锁
由于本地锁只能锁住当前进程，所以我们需要分布式锁
- 问题1: setnx占好了位，业务代码异常或者程序在页面过程中宕机，没有执行删除锁的逻辑，就会造成死锁问题
- 问题2: 如果业务时间很长。锁自己过期了，我们直接删除，有可能把别人正在持有的锁给删除   
- 解决: 加锁删锁都必须保证原子性，给锁名字加上一个uuid避免重复，使用redis+lua脚本完成原子性删除<br>
关于续期问题，直接把缓存时间放长一点进行解决