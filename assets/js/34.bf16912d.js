(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{408:function(a,s,t){"use strict";t.r(s);var r=t(3),e=Object(r.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#哪些数据适合放到缓存"}},[a._v("哪些数据适合放到缓存")])]),t("li",[t("a",{attrs:{href:"#本地缓存"}},[a._v("本地缓存")])]),t("li",[t("a",{attrs:{href:"#redis缓存"}},[a._v("redis缓存")])]),t("li",[t("a",{attrs:{href:"#内存问题"}},[a._v("内存问题")]),t("ul",[t("li",[t("a",{attrs:{href:"#堆外溢出异常"}},[a._v("堆外溢出异常")])]),t("li",[t("a",{attrs:{href:"#解决方案"}},[a._v("解决方案")])])])]),t("li",[t("a",{attrs:{href:"#高并发缓存失效问题"}},[a._v("高并发缓存失效问题")]),t("ul",[t("li",[t("a",{attrs:{href:"#缓存穿透"}},[a._v("缓存穿透")])]),t("li",[t("a",{attrs:{href:"#缓存雪崩"}},[a._v("缓存雪崩")])]),t("li",[t("a",{attrs:{href:"#缓存击穿"}},[a._v("缓存击穿")])])])]),t("li",[t("a",{attrs:{href:"#加锁"}},[a._v("加锁")]),t("ul",[t("li",[t("a",{attrs:{href:"#单机模式加锁"}},[a._v("单机模式加锁")])]),t("li",[t("a",{attrs:{href:"#集群模式加锁"}},[a._v("集群模式加锁")])])])]),t("li",[t("a",{attrs:{href:"#整合redisson"}},[a._v("整合redisson")])]),t("li",[t("a",{attrs:{href:"#使用spring-cache"}},[a._v("使用spring cache")]),t("ul",[t("li",[t("a",{attrs:{href:"#简介"}},[a._v("简介")])]),t("li",[t("a",{attrs:{href:"#整合spring-cache简化缓存开发"}},[a._v("整合spring cache简化缓存开发")])]),t("li",[t("a",{attrs:{href:"#cacheable"}},[a._v("@Cacheable")])]),t("li",[t("a",{attrs:{href:"#spring-cache的不足"}},[a._v("spring cache的不足")])])])])])]),t("p"),a._v(" "),t("h2",{attrs:{id:"哪些数据适合放到缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哪些数据适合放到缓存"}},[a._v("#")]),a._v(" 哪些数据适合放到缓存")]),a._v(" "),t("ul",[t("li",[a._v("即时性，数据一致性要求不高的")]),a._v(" "),t("li",[a._v("访问量大且更新频率不高的(读多，写少)\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ShuiLinzi/blog-image@master/%E5%90%8E%E7%AB%AF/%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B.2mcj5cis3se0.png",alt:"缓存流程"}})])]),a._v(" "),t("h2",{attrs:{id:"本地缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地缓存"}},[a._v("#")]),a._v(" 本地缓存")]),a._v(" "),t("p",[a._v("项目是单体应用，很方便，很快，但是如果是分布式集群环境下，一旦对数据进行修改，比如对一号机器修改，但是由于负载均衡到二号三号机器的数据无法修改，也就是说本地缓存会产生数据一致性的问题。解决办法，使用服务器击群使用一个公共的共同的缓存中间件，redis能实现此功能\n"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ShuiLinzi/blog-image@master/%E5%90%8E%E7%AB%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.3wivdp10sts.png",alt:"分布式缓存"}})]),a._v(" "),t("h2",{attrs:{id:"redis缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis缓存"}},[a._v("#")]),a._v(" redis缓存")]),a._v(" "),t("ul",[t("li",[a._v("给缓存中放json字符串，json跨语言，跨平台兼容，拿出来的时候也是字符串，这样可以保持格式的统一")])]),a._v(" "),t("h2",{attrs:{id:"内存问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存问题"}},[a._v("#")]),a._v(" 内存问题")]),a._v(" "),t("h3",{attrs:{id:"堆外溢出异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆外溢出异常"}},[a._v("#")]),a._v(" 堆外溢出异常")]),a._v(" "),t("ul",[t("li",[a._v("springboot2.0以后默认使用lettcue作为操作redis的客户端。它使用netty进行网络通信")]),a._v(" "),t("li",[a._v("lettuce的bug导致netty堆外内存溢出")])]),a._v(" "),t("h3",{attrs:{id:"解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),t("p",[a._v("调大堆外内存并不能从根本上解决问题，迟早会出现这个问题"),t("br"),a._v("\nredisTemplate:lettcue,jedis都是操控redis的底层客户端。spring再次封装成了redisTemplate")]),a._v(" "),t("ul",[t("li",[a._v("升级lettuce客户端")]),a._v(" "),t("li",[a._v("切换使用jedis客户端(我使用了此种方法，因为视频里面用的是这个，2333)")])]),a._v(" "),t("h2",{attrs:{id:"高并发缓存失效问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高并发缓存失效问题"}},[a._v("#")]),a._v(" 高并发缓存失效问题")]),a._v(" "),t("h3",{attrs:{id:"缓存穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[a._v("#")]),a._v(" 缓存穿透")]),a._v(" "),t("p",[a._v("缓存穿透指查询一个不存在的数据，由于缓存不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的null写入缓存，这将导致这个不存在的数据每次都要请求到存储层去查询，失去了缓存的意义"),t("br"),t("br"),a._v("\n风险:利用不存在的数据进行攻击，数据库瞬间压力增大，最终导致崩溃"),t("br"),t("br"),a._v("\n解决:将null结果缓存，并加入短暂的过期时间")]),a._v(" "),t("h3",{attrs:{id:"缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[a._v("#")]),a._v(" 缓存雪崩")]),a._v(" "),t("p",[a._v("缓存雪崩是指我们设置缓存时key采用了相同的过期时间，导致缓存在某一个时刻同时失效，请求全部转发到数据库，数据库瞬时压力过重雪崩"),t("br"),t("br"),a._v("\n解决:原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的\n重复率就会降低，就很难引发集体失效的事件")]),a._v(" "),t("h3",{attrs:{id:"缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[a._v("#")]),a._v(" 缓存击穿")]),a._v(" "),t("p",[a._v("对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常热点的数据这个时候，需要考虑一个问题：如果这个 key 在大量请求同时进来前正好失效，那么所\n有对这个 key 的数据查询都落到 db，我们称为缓存击穿。"),t("br"),t("br"),a._v("\n解决:加锁"),t("br"),t("br"),a._v("\n(个人感觉：上述问题不用缓存也会存在吧，比如没有缓存高并发直接访问数据库，不也会炸吗)")]),a._v(" "),t("h2",{attrs:{id:"加锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加锁"}},[a._v("#")]),a._v(" 加锁")]),a._v(" "),t("h3",{attrs:{id:"单机模式加锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单机模式加锁"}},[a._v("#")]),a._v(" 单机模式加锁")]),a._v(" "),t("p",[a._v("单机模式加锁，使用synchronized(this)进行加锁")]),a._v(" "),t("h3",{attrs:{id:"集群模式加锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群模式加锁"}},[a._v("#")]),a._v(" 集群模式加锁")]),a._v(" "),t("p",[a._v("由于本地锁只能锁住当前进程，所以我们需要分布式锁")]),a._v(" "),t("ul",[t("li",[a._v("问题1: setnx占好了位，业务代码异常或者程序在页面过程中宕机，没有执行删除锁的逻辑，就会造成死锁问题")]),a._v(" "),t("li",[a._v("问题2: 如果业务时间很长。锁自己过期了，我们直接删除，有可能把别人正在持有的锁给删除")]),a._v(" "),t("li",[a._v("解决: 加锁删锁都必须保证原子性，给锁名字加上一个uuid避免重复，使用redis+lua脚本完成原子性删除"),t("br"),a._v("\n关于续期问题，直接把缓存时间放长一点进行解决")])]),a._v(" "),t("h2",{attrs:{id:"整合redisson"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整合redisson"}},[a._v("#")]),a._v(" 整合redisson")]),a._v(" "),t("p",[a._v("引入依赖，配置redisson\n以后现用现查吧..")]),a._v(" "),t("h2",{attrs:{id:"使用spring-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用spring-cache"}},[a._v("#")]),a._v(" 使用spring cache")]),a._v(" "),t("h3",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),t("p",[a._v("Spring 从 3.1 开始定义了 org.springframework.cache.Cache\n和 org.springframework.cache.CacheManager 接口来统一不同的缓存技术；\n并支持使用 JCache（JSR-107）注解简化我们开发")]),a._v(" "),t("ul",[t("li",[a._v("每次调用需要缓存功能的方法时，Spring 会检查检查指定参数的指定的目标方法是否已\n经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓\n存结果后返回给用户。下次调用直接从缓存中获取")]),a._v(" "),t("li",[a._v("使用Spring 缓存抽象时我们需要关注以下两点\n"),t("ul",[t("li",[a._v("1、确定方法需要被缓存以及他们的缓存策略")]),a._v(" "),t("li",[a._v("2、从缓存中读取之前缓存存储的数据")])])])]),a._v(" "),t("h3",{attrs:{id:"整合spring-cache简化缓存开发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整合spring-cache简化缓存开发"}},[a._v("#")]),a._v(" 整合spring cache简化缓存开发")]),a._v(" "),t("ul",[t("li",[a._v("引入依赖 spring-boot-stater-catch")])]),a._v(" "),t("div",{staticClass:"language-xml line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-xml"}},[t("code",[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("dependency")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("groupId")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("org.springframework.boot"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("groupId")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("artifactId")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("spring-boot-starter-cache"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("artifactId")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("dependency")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("ul",[t("li",[a._v("写配置\n"),t("ul",[t("li",[a._v("boot自动配置好了缓存管理器RediscacheManager")]),a._v(" "),t("li",[a._v("手动配置redis作为缓存")])])])]),a._v(" "),t("div",{staticClass:"language-xml line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-xml"}},[t("code",[a._v("spring.cache.type=redis\n\n#spring.cache.cache-names=qq,毫秒为单位\nspring.cache.redis.time-to-live=3600000\n\n#如果指定了前缀就用我们指定的前缀，如果没有就默认使用缓存的名字作为前缀\n#spring.cache.redis.key-prefix=CACHE_\nspring.cache.redis.use-key-prefix=true\n\n#是否缓存空值，防止缓存穿透\nspring.cache.redis.cache-null-values=true\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br")])]),t("ul",[t("li",[a._v("使用缓存注解\n"),t("ul",[t("li",[a._v("@Cacheable  ：触发将数据保存到缓存的操作；")]),a._v(" "),t("li",[a._v("@CacheEvict  : 触发将数据从缓存删除的操作；")]),a._v(" "),t("li",[a._v("@CachePut ：不影响方法执行更新缓存；")]),a._v(" "),t("li",[a._v("@Cacheing：组合以上多个操作；")]),a._v(" "),t("li",[a._v("@CacheConfig：在类级别共享缓存的相同配置；\n1）开启缓存功能@EnableCaching\n2）只需要使用注解就能完成缓存操作")])])])]),a._v(" "),t("h3",{attrs:{id:"cacheable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cacheable"}},[a._v("#")]),a._v(" @Cacheable")]),a._v(" "),t("p",[a._v("1.每个需要缓存的数据我们都来指定要放到那个名字的缓存，缓存分区(可以按照业务类型分)"),t("br"),t("br"),a._v("\n2.默认行为")]),a._v(" "),t("ul",[t("li",[a._v("如果缓存中有，方法不调用")]),a._v(" "),t("li",[a._v("key默认自动生成")]),a._v(" "),t("li",[a._v("缓存的value值，默认使用jdk序列化机制，然后会把序列化后的数据存到redis中")]),a._v(" "),t("li",[a._v("默认ttl(生存时间time to live)为-1(永不过期)"),t("br"),t("br")])]),a._v(" "),t("p",[a._v("3.自定义")]),a._v(" "),t("ul",[t("li",[a._v("指定生成缓存使用的key，key属性指定，接受一个SpEL表达式(SpEL（Spring Expression Language），即Spring表达式语言)")]),a._v(" "),t("li",[a._v("指定缓存数据的存活时间，配置文件中修改ttl")]),a._v(" "),t("li",[a._v("将数据保存为json格式(改变序列化机制)")])]),a._v(" "),t("h3",{attrs:{id:"spring-cache的不足"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-cache的不足"}},[a._v("#")]),a._v(" spring cache的不足")]),a._v(" "),t("p",[a._v("1）、读模式")]),a._v(" "),t("p",[a._v("缓存穿透：查询一个null数据。解决方案：缓存空数据，可通过spring.cache.redis.cache-null-values=true\n缓存击穿：大量并发进来同时查询一个正好过期的数据。解决方案：加锁 ? 默认是无加锁的;\n使用sync = true来解决击穿问题\n缓存雪崩：大量的key同时过期。解决：加随机时间。"),t("br"),a._v("\n2）、写模式：（缓存与数据库一致）")]),a._v(" "),t("p",[a._v("读写加锁。\n引入Canal，感知到MySQL的更新去更新Redis\n读多写多，直接去数据库查询就行"),t("br"),a._v("\n3）、总结：")]),a._v(" "),t("p",[a._v("常规数据（读多写少，即时性，一致性要求不高的数据，完全可以使用Spring-Cache）：")]),a._v(" "),t("p",[a._v("写模式(只要缓存的数据有过期时间就足够了)")]),a._v(" "),t("p",[a._v("特殊数据：特殊设计")])])}),[],!1,null,null,null);s.default=e.exports}}]);